// swiftlint:disable line_length
// swiftlint:disable variable_name

import Foundation
#if os(iOS) || os(tvOS) || os(watchOS)
import UIKit
#elseif os(OSX)
import AppKit
#endif

@testable import <YOUR_APP_TARGET_NAME>

{% macro helperClassPrefix %}_{% endmacro %}
{% macro swiftifyMethodName name %}{{ name | replace:"(","_" | replace:")","" | replace:":","_" | replace:"`","" | snakeToCamelCase | lowerFirstWord }}{% endmacro %}
{% macro underlyingVariableName variable %}_{{ variable.name }}{% endmacro %}
{% macro mockedClassName className %}Mock{{ className }}{% endmacro %}
{% macro functionEnumName %}funcs{% endmacro %}
{% macro functionKeyName method count %}{{ method.shortName }}{{ count }}{% endmacro %}
{% macro parametersEnumName method count %}{% call functionKeyName method count %}Parameters{% endmacro %}
{% macro invocationsVariableName  %}invocations{% endmacro %}
{% macro actionsVariableName  %}actions{% endmacro %}
{% macro uniqueIdentifierForEnumParameter method param %}{{ method.name }}.{{ param.name }}{% endmacro %}

{% macro mockMethod method count %}
    //MARK: - {{ method.shortName }}

    {% if method.isInitializer %}required {{ method.name }}{% else %}func {{ method.name }}{% endif %}{% if method.throws and not method.isInitializer %}{{ ' throws' }}{% endif %}{% if not method.returnTypeName.isVoid and not method.isInitializer %} -> {{ method.returnTypeName }}{% endif %} {
        let functionName = {% call functionEnumName %}.{% call functionKeyName method count %}
        {% if method.throws and not method.isInitializer %}
        if let error = {% call actionsVariableName %}.error(for: functionName) {
            throw error
        }
        {% endif %}
        let invocation = {% call helperClassPrefix %}Invocation(name: functionName.rawValue)
        {% for param in method.parameters %}
        {% if param.isOptional %}
        if let {{ param.name }} = {{ param.name }} {
            invocation.set(parameter: {{ param.name }}, forKey: {% call parametersEnumName method count %}.{{ param.name }})
        }
        {% else %}
        invocation.set(parameter: {{ param.name }}, forKey: {% call parametersEnumName method count %}.{{ param.name }})
        {% endif %}
        {% endfor %}
        {% call invocationsVariableName %}.record(invocation)
        {% call actionsVariableName %}.closure(for: functionName)?()
        {% if not method.returnTypeName.isVoid and not method.isInitializer %}
        {% if method.annotations.returnValue %}
        {% call actionsVariableName %}.setDefaultReturnValue({{ method.annotations.returnValue }}, for: functionName)
        {% endif %}
        return {% call actionsVariableName %}.returnValue(for: functionName){% if method.isOptionalReturnType %} as? {% else %} as! {% endif %}{{ method.unwrappedReturnTypeName }}
        {% endif %}
    }
{% endmacro %}

{% macro mockOptionalVariable variable %}
    {% if variable.annotations.value %}
    var {{ variable.name }}: {{ variable.typeName }} = {{ variable.annotations.value }}
    {% else %}
    var {{ variable.name }}: {{ variable.typeName }}
    {% endif %}
{% endmacro %}

{% macro mockNonOptionalArrayOrDictionaryVariable variable %}
    {% if variable.annotations.value %}
    var {{ variable.name }}: {{ variable.typeName }} = {{ variable.annotations.value }}
    {% else %}
    var {{ variable.name }}: {{ variable.typeName }} = {% if variable.isArray %}[]{% elif variable.isDictionary %}[:]{% endif %}
    {% endif %}
{% endmacro %}

{% macro mockNonOptionalVariable variable %}
    var {{ variable.name }}: {{ variable.typeName }} {
        get { return {% call underlyingVariableName variable %} }
        set(value) { {% call underlyingVariableName variable %} = value }
    }
    {% if variable.annotations.value %}
    var {% call underlyingVariableName variable %}: {{ variable.typeName }}! = {{ variable.annotations.value }}
    {% elif variable.type.based.Mockable and variable.type.annotations.name %}
    var {% call underlyingVariableName variable %}: {{ variable.typeName }}! = Mock{{ variable.type.annotations.name }}()
    {% elif variable.type.based.Mockable %}
    var {% call underlyingVariableName variable %}: {{ variable.typeName }}! = Mock{{ variable.typeName }}()
    {% elif variable.typeName|hasPrefix:"NS" or variable.typeName|hasPrefix:"UI" %}
    var {% call underlyingVariableName variable %}: {{ variable.typeName }}! = {{ variable.typeName }}()
    {% else %}
    var {% call underlyingVariableName variable %}: {{ variable.typeName }}!
    {% endif %}
{% endmacro %}

// MARK: - Sourcery Helper

protocol {% call helperClassPrefix %}StringRawRepresentable: RawRepresentable {
  var rawValue: String { get }
}

final class {% call helperClassPrefix %}Invocation {
  let name: String
  let date = Date()
  private var parameters: [String: Any] = [:]

  init(name: String) {
    self.name = name
  }

  fileprivate func set<T: {% call helperClassPrefix %}StringRawRepresentable>(parameter: Any, forKey key: T) {
    parameters[key.rawValue] = parameter
  }
  fileprivate func parameter<T: {% call helperClassPrefix %}StringRawRepresentable>(for key: T) -> Any? {
    return parameters[key.rawValue]
  }
}

final class {% call helperClassPrefix %}Actions {
  enum Keys: String, {% call helperClassPrefix %}StringRawRepresentable {
    case closure
    case returnValue
    case defaultReturnValue
    case error
  }
  private var invocations: [{% call helperClassPrefix %}Invocation] = []

  // MARK: - closure

  func setClosure<T: {% call helperClassPrefix %}StringRawRepresentable>(_ value: () -> Void, for functionName: T) {
    let invocation = self.invocation(for: functionName)
    invocation.set(parameter: value, forKey: Keys.closure)
  }
  func closure<T: {% call helperClassPrefix %}StringRawRepresentable>(for functionName: T) -> (() -> Void)? {
    let invocation = self.invocation(for: functionName)
    return invocation.parameter(for: Keys.closure) as? (() -> Void)
  }

  // MARK: - returnValue

  func setReturnValue<T: {% call helperClassPrefix %}StringRawRepresentable>(_ value: Any, for functionName: T) {
    let invocation = self.invocation(for: functionName)
    invocation.set(parameter: value, forKey: Keys.returnValue)
  }
  func returnValue<T: {% call helperClassPrefix %}StringRawRepresentable>(for functionName: T) -> Any? {
    let invocation = self.invocation(for: functionName)
    return invocation.parameter(for: Keys.returnValue) ?? invocation.parameter(for: Keys.defaultReturnValue)
  }

  // MARK: - defaultReturnValue

  fileprivate func setDefaultReturnValue<T: {% call helperClassPrefix %}StringRawRepresentable>(_ value: Any, for functionName: T) {
    let invocation = self.invocation(for: functionName)
    invocation.set(parameter: value, forKey: Keys.defaultReturnValue)
  }
  fileprivate func defaultReturnValue<T: {% call helperClassPrefix %}StringRawRepresentable>(for functionName: T) -> Any? {
    let invocation = self.invocation(for: functionName)
    return invocation.parameter(for: Keys.defaultReturnValue) as? (() -> Void)
  }

  // MARK: - error

  func setError<T: {% call helperClassPrefix %}StringRawRepresentable>(_ value: Error, for functionName: T) {
    let invocation = self.invocation(for: functionName)
    invocation.set(parameter: value, forKey: Keys.error)
  }
  func error<T: {% call helperClassPrefix %}StringRawRepresentable>(for functionName: T) -> Error? {
    let invocation = self.invocation(for: functionName)
    return invocation.parameter(for: Keys.error) as? Error
  }

  // MARK: - private

  private func invocation<T: {% call helperClassPrefix %}StringRawRepresentable>(for name: T) -> {% call helperClassPrefix %}Invocation {
    if let invocation = invocations.filter({ $0.name == name.rawValue }).first {
      return invocation
    }
    let invocation = {% call helperClassPrefix %}Invocation(name: name.rawValue)
    invocations += [invocation]
    return invocation
  }
}

final class {% call helperClassPrefix %}Invocations {
  private var history = [{% call helperClassPrefix %}Invocation]()

  fileprivate func record(_ invocation: {% call helperClassPrefix %}Invocation) {
    history += [invocation]
  }

  func isInvoked<T: {% call helperClassPrefix %}StringRawRepresentable>(_ name: T) -> Bool {
    return history.contains(where: { $0.name == name.rawValue })
  }

  func numOfTimesInvoked<T: {% call helperClassPrefix %}StringRawRepresentable>(_ name: T) -> Int {
    return history.filter {  $0.name == name.rawValue }.count
  }

  func allInvocations() -> [{% call helperClassPrefix %}Invocation] {
    return history.sorted { $0.date < $1.date }
  }

  func findInvocations<T: {% call helperClassPrefix %}StringRawRepresentable>(for name: T) -> [{% call helperClassPrefix %}Invocation] {
    return history.filter {  $0.name == name.rawValue }.sorted { $0.date < $1.date }
  }

  func findParameter<T: {% call helperClassPrefix %}StringRawRepresentable, U: {% call helperClassPrefix %}StringRawRepresentable>(_ key: T, inFunction name: U) -> Any? {
    return history.filter {  $0.name == name.rawValue }.first?.parameter(for: key)
  }
}

// MARK: - Sourcery Mocks
{% for type in types.protocols where type.based.Mockable or type|annotated:"Mockable" %}

{% if type.name != "Mockable" %}
class {% if type.annotations.name %}{% call mockedClassName type.annotations.name %}{% else %}{% call mockedClassName type.name %}{% endif %}{% if type.annotations.inherits %}: {{ type.annotations.inherits }}{% else %}: NSObject{% endif %}, {{ type.name }} {
{% for variable in type.allVariables|!definedInExtension %}
    {% if variable.isOptional %}
    {% call mockOptionalVariable variable %}
    {% elif variable.isArray or variable.isDictionary %}
    {% call mockNonOptionalArrayOrDictionaryVariable variable %}
    {% else %}
    {% call mockNonOptionalVariable variable %}
    {% endif %}
{% endfor %}
    {% if not type.allMethods.count == 0 %}
    let {% call invocationsVariableName %} = {% call helperClassPrefix %}Invocations()
    let {% call actionsVariableName %} = {% call helperClassPrefix %}Actions()

    enum {% call functionEnumName %}: String, {% call helperClassPrefix %}StringRawRepresentable {
    {% for method in type.allMethods|!definedInExtension %}
      case {% call functionKeyName method forloop.counter %}
    {% endfor %}
    }
    {% for method in type.allMethods|!definedInExtension %}
    {% if not method.parameters.count == 0 %}
    enum {% call parametersEnumName method forloop.counter %}: String, {% call helperClassPrefix %}StringRawRepresentable {
    {% for parameter in method.parameters %}
      case {{ parameter.name }} = "{% call uniqueIdentifierForEnumParameter method parameter %}"
    {% endfor %}
    }
    {% endif %}
    {% endfor %}
    {% for method in type.allMethods|!definedInExtension %}

    {% call mockMethod method forloop.counter %}
    {% endfor %}
    {% endif %}
}
{% endif %}
{% endfor %}